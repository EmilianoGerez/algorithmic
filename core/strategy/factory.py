"""
Strategy Factory for Phase 8 Integration

This module provides the StrategyFactory that wires together all Phase 1-7 components:
- Indicators → Detectors → ZoneWatcher → FSM → Risk → PaperBroker

The factory builds a complete strategy pipeline from configuration and coordinates
all components for deterministic backtesting.
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Any
from dataclasses import dataclass

from core.detectors.fvg import FVGDetector
from core.entities import Candle
from core.indicators.base import IndicatorPack
from core.indicators.ema import EMA


@dataclass
class HTFStack:
    """Container for HTF strategy components with lifecycle management."""
    pool_registry: Any = None
    overlap_detector: Any = None
    pool_manager: Any = None
    zone_watcher: Any = None
    detectors: list = None
    time_aggregators: dict = None
    
    def shutdown(self):
        """Clean shutdown for all components."""
        for comp in [self.pool_registry, self.overlap_detector, self.pool_manager, self.zone_watcher]:
            if hasattr(comp, 'shutdown'):
                comp.shutdown()
        
        if self.detectors:
            for detector in self.detectors:
                if hasattr(detector, 'shutdown'):
                    detector.shutdown()
                    
        if self.time_aggregators:
            for aggregator in self.time_aggregators.values():
                if hasattr(aggregator, 'shutdown'):
                    aggregator.shutdown()
from core.strategy import (
    OverlapDetector,
    PoolManager,
    PoolRegistry,
    TimeAggregator,
    ZoneWatcher,
    ZoneWatcherConfig,
)
from services.metrics import MetricsCollector, measure_operation

logger = logging.getLogger(__name__)


class TradingSignal:
    """Signal generated by the strategy FSM when conditions are met."""

    def __init__(
        self,
        symbol: str,
        side: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        size: float,
        **kwargs: Any,
    ) -> None:
        """Initialize trading signal.

        Args:
            symbol: Trading symbol
            side: "buy" or "sell"
            entry_price: Entry price level
            stop_loss: Stop loss price
            take_profit: Take profit price
            size: Position size
            timestamp: Signal timestamp
            reason: Signal generation reason
        """
        self.symbol = symbol
        self.side = side
        self.entry_price = entry_price
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.size = size
        self.timestamp = kwargs.get("timestamp")
        self.reason = kwargs.get("reason", "signal generated")

    def __repr__(self) -> str:
        return (
            f"TradingSignal({self.side} {self.size} {self.symbol} @ {self.entry_price})"
        )


class MockZoneWatcher:
    """Mock Zone Watcher for Phase 8 testing."""

    def __init__(self, config: Any) -> None:
        self.config = config
        self.last_signal_time: datetime | None = None

    def update(self, candle: Candle, indicators: IndicatorPack) -> TradingSignal | None:
        """Check for zone entries and generate signals.

        Args:
            candle: Current market candle
            indicators: Current indicator snapshot

        Returns:
            TradingSignal if conditions met, None otherwise
        """
        # Enhanced signal logic: generate signals based on multiple conditions
        ema21 = indicators.ema21_value
        ema50 = indicators.ema50_value

        if ema21 is None or ema50 is None:
            return None

        # Check cooldown period (reduced to 10 minutes for more signals)
        if (
            self.last_signal_time is not None
            and (candle.ts - self.last_signal_time).total_seconds() < 600
        ):
            return None

        # Signal conditions:
        # 1. Price above EMA21 and EMA21 > EMA50 (bullish)
        # 2. Price has moved more than 0.1% from EMA21 (momentum)
        price_above_ema21 = candle.close > ema21
        ema21_above_ema50 = ema21 > ema50
        momentum_threshold = (
            abs(candle.close - ema21) / ema21 > 0.001
        )  # 0.1% minimum move

        if price_above_ema21 and ema21_above_ema50 and momentum_threshold:
            self.last_signal_time = candle.ts

            # Calculate signal parameters
            entry = candle.close
            atr = abs(candle.high - candle.low)  # Simple ATR approximation
            stop_loss = entry - (atr * 1.5)  # 1.5x ATR stop
            take_profit = entry + (atr * 3.0)  # 2:1 risk/reward

            # Ensure minimum risk/reward ratio
            risk_distance = entry - stop_loss
            if risk_distance > 0:
                reward_distance = take_profit - entry
                if reward_distance / risk_distance < 1.5:  # Minimum 1.5:1 RR
                    take_profit = entry + (risk_distance * 2.0)

                return TradingSignal(
                    symbol=str(getattr(self.config, "symbol", "EURUSD")),
                    side="buy",
                    entry_price=entry,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    size=100.0,  # Will be sized by RiskManager
                    timestamp=candle.ts,
                    reason="EMA_momentum_bullish",
                )

        return None


class MockRiskManager:
    """Mock Risk Manager for position sizing."""

    def __init__(self, config: Any) -> None:
        self.config = config
        # Access nested risk configuration
        if hasattr(config, "risk") and hasattr(config.risk, "risk_per_trade"):
            self.risk_per_trade = config.risk.risk_per_trade
        else:
            self.risk_per_trade = 0.01  # Default 1% risk

    def size_position(self, signal: TradingSignal, account_balance: float) -> float:
        """Calculate position size based on risk parameters.

        Args:
            signal: Trading signal with price levels
            account_balance: Current account balance

        Returns:
            Position size in base currency
        """
        # Calculate risk amount
        risk_amount = account_balance * self.risk_per_trade

        # Calculate distance to stop loss
        if signal.side == "buy":
            risk_per_unit = signal.entry_price - signal.stop_loss
        else:
            risk_per_unit = signal.stop_loss - signal.entry_price

        if risk_per_unit <= 0:
            return 0.0

        # Calculate position size
        position_size = risk_amount / risk_per_unit

        # Apply maximum position size limit if configured
        max_size_attr = getattr(self.config, "max_position_size", None)
        max_size: float = (
            float(max_size_attr) if max_size_attr is not None else float("inf")
        )
        result: float = min(float(position_size), max_size)
        return result


class MockPaperBroker:
    """Mock Paper Broker for trade execution and tracking."""

    def __init__(
        self, config: Any, metrics_collector: MetricsCollector | None = None
    ) -> None:
        self.config = config
        self.metrics_collector = metrics_collector
        self.balance: float
        # Access nested account configuration
        if hasattr(config, "account") and hasattr(config.account, "initial_balance"):
            self.balance = float(config.account.initial_balance)
        else:
            self.balance = 10000.0  # Default balance
        self.positions: dict[str, Any] = {}
        self.trades: list[dict[str, Any]] = []
        self.trade_id = 0

    def submit_order(self, signal: TradingSignal, size: float) -> str:
        """Submit order to paper broker.

        Args:
            signal: Trading signal
            size: Calculated position size

        Returns:
            Trade ID
        """
        self.trade_id += 1
        trade_id = f"trade_{self.trade_id}"

        # Apply commission
        if hasattr(self.config, "account") and hasattr(
            self.config.account, "commission"
        ):
            commission_rate = self.config.account.commission
        else:
            commission_rate = 0.001  # Default 0.1%
        commission = size * signal.entry_price * commission_rate
        self.balance -= commission

        # Record trade
        trade = {
            "id": trade_id,
            "symbol": signal.symbol,
            "side": signal.side,
            "size": size,
            "entry_price": signal.entry_price,
            "stop_loss": signal.stop_loss,
            "take_profit": signal.take_profit,
            "entry_time": signal.timestamp,
            "commission": commission,
            "status": "open",
            "exit_price": None,
            "exit_time": None,
            "pnl": 0.0,
        }

        self.trades.append(trade)
        self.positions[trade_id] = trade

        logger.info(f"Order submitted: {signal} size={size:.2f}")
        return trade_id

    def update_market_data(self, candle: Candle) -> None:
        """Update broker with latest market data.

        Args:
            candle: Current market candle
        """
        # Update positions with current market data
        self.update_positions(candle)

    def update_positions(self, candle: Candle) -> None:
        """Update open positions with current market data.

        Args:
            candle: Current market candle
        """
        closed_trades = []

        for trade_id, trade in self.positions.items():
            if trade["status"] != "open":
                continue

            current_price = candle.close

            # Check stop loss and take profit
            if trade["side"] == "buy":
                if current_price <= trade["stop_loss"]:
                    # Stop loss hit
                    self._close_trade(trade, current_price, candle.ts, "stop_loss")
                    closed_trades.append(trade_id)
                elif current_price >= trade["take_profit"]:
                    # Take profit hit
                    self._close_trade(trade, current_price, candle.ts, "take_profit")
                    closed_trades.append(trade_id)
            else:  # sell
                if current_price >= trade["stop_loss"]:
                    # Stop loss hit
                    self._close_trade(trade, current_price, candle.ts, "stop_loss")
                    closed_trades.append(trade_id)
                elif current_price <= trade["take_profit"]:
                    # Take profit hit
                    self._close_trade(trade, current_price, candle.ts, "take_profit")
                    closed_trades.append(trade_id)

        # Remove closed trades from positions
        for trade_id in closed_trades:
            del self.positions[trade_id]

    def _close_trade(
        self, trade: dict[str, Any], exit_price: float, exit_time: Any, reason: str
    ) -> None:
        """Close a trade and calculate PnL.

        Args:
            trade: Trade dictionary
            exit_price: Exit price
            exit_time: Exit timestamp
            reason: Closure reason
        """
        # Calculate PnL
        if trade["side"] == "buy":
            pnl = (exit_price - trade["entry_price"]) * trade["size"]
        else:
            pnl = (trade["entry_price"] - exit_price) * trade["size"]

        # Apply commission on exit
        if hasattr(self.config, "account") and hasattr(
            self.config.account, "commission"
        ):
            commission_rate = self.config.account.commission
        else:
            commission_rate = 0.001  # Default 0.1%
        exit_commission = trade["size"] * exit_price * commission_rate
        pnl -= exit_commission

        # Update trade record
        trade["exit_price"] = exit_price
        trade["exit_time"] = exit_time
        trade["pnl"] = pnl
        trade["status"] = reason
        trade["exit_commission"] = exit_commission

        # Update balance
        self.balance += pnl

        # Find and update the trade in the trades list
        for i, stored_trade in enumerate(self.trades):
            if stored_trade["id"] == trade["id"]:
                self.trades[i] = trade.copy()
                break

        # Record trade with metrics collector
        if self.metrics_collector:
            duration_minutes = (exit_time - trade["entry_time"]).total_seconds() / 60.0
            total_fees = trade["commission"] + trade.get("exit_commission", 0)
            self.metrics_collector.record_trade(
                pnl=pnl,
                fees=total_fees,
                duration_minutes=duration_minutes,
                position_size=abs(trade["size"]),
            )

        logger.info(f"Trade closed: {trade['id']} PnL=${pnl:.2f} reason={reason}")

    def get_balance(self) -> float:
        """Get current account balance."""
        return self.balance

    def get_trades(self) -> list[dict[str, Any]]:
        """Get all trades."""
        return self.trades.copy()


class IntegratedStrategy:
    """Integrated strategy that coordinates all Phase 1-7 components."""

    def __init__(
        self, config: Any, broker: MockPaperBroker, risk_manager: MockRiskManager
    ) -> None:
        """Initialize integrated strategy.

        Args:
            config: Strategy configuration
            broker: Paper broker instance
            risk_manager: Risk manager instance
        """
        self.config = config
        self.broker = broker
        self.risk_manager = risk_manager

        # Initialize indicators
        self.indicators = IndicatorPack()

        # Initialize strategy components based on strategy configuration
        logger.info(f"Config type: {type(config)}")
        logger.info(f"Strategy name: {getattr(config.strategy, 'name', 'NO_NAME')}")
        
        use_mock = getattr(config.strategy, 'use_mock_strategy', False)
        
        # Config validation
        if not use_mock:
            # Validate HLZ configuration when using real HTF strategy
            if (not config.detectors.get("pivot", {}).get("enabled", False) and 
                config.hlz.get("min_members", 2) > 2):
                logger.warning(
                    "HLZ min_members > 2 but pivot detector disabled. "
                    "HLZ creation probability may be low with FVG-only detection."
                )
        
        if not use_mock and config.strategy.name.lower() == "htf_liquidity_mtf":
            # ── Build full HTF liquidity detection stack ────────────────────────────
            logger.info("Building real HTF liquidity strategy")
            
            # Initialize HTF stack container
            self.htf_stack = HTFStack()
            
            # Time aggregators (built first, used by detectors)
            self.htf_stack.time_aggregators = {}
            htf_list = getattr(config.strategy, "htf_list", ["H4", "D1"])
            for tf_name in htf_list:
                tf_minutes = 240 if tf_name == "H4" else 1440 if tf_name == "D1" else int(tf_name[:-1])
                aggregator = TimeAggregator(
                    tf_minutes=tf_minutes,
                    source_tf_minutes=config.aggregation.get("source_tf_minutes", 5),
                    buffer_size=config.aggregation.get("buffer_size", 1000)
                )
                self.htf_stack.time_aggregators[tf_name] = aggregator
            
            # Core registry and overlap detection
            from .pool_registry import PoolRegistryConfig
            from .overlap import OverlapConfig
            
            registry_config = PoolRegistryConfig(
                grace_period_minutes=config.pools["grace_period_minutes"],
                max_pools_per_tf=config.pools["max_pools_per_tf"]
            )
            self.htf_stack.pool_registry = PoolRegistry(registry_config)
            
            overlap_config = OverlapConfig(
                min_members=config.hlz["min_members"],
                min_strength=config.hlz["min_strength"],
                tf_weight=config.hlz["tf_weight"],
                merge_tolerance=config.hlz["merge_tolerance"],
                side_mixing=config.hlz["side_mixing"]
            )
            self.htf_stack.overlap_detector = OverlapDetector(overlap_config, self.htf_stack.pool_registry)
            
            # Pool manager coordinates detector events → pools → HLZ
            from .pool_manager import PoolManagerConfig
            
            pool_mgr_config = PoolManagerConfig(
                enable_event_logging=True
            )
            self.htf_stack.pool_manager = PoolManager(self.htf_stack.pool_registry, pool_mgr_config)
            
            # Zone watcher monitors pool/HLZ touches → signal candidates
            from .signal_candidate import CandidateConfig
            
            candidate_config = CandidateConfig(
                expiry_minutes=config.candidate["expiry_minutes"],
                ema_alignment=config.candidate["filters"]["ema_alignment"],
                volume_multiple=config.candidate["filters"]["volume_multiple"],
                killzone_start=config.candidate["filters"]["killzone"][0],
                killzone_end=config.candidate["filters"]["killzone"][1],
                regime_allowed=config.candidate["filters"]["regime"]
            )
            
            zone_config = ZoneWatcherConfig(
                price_tolerance=config.zone_watcher["price_tolerance"],
                confirm_closure=config.zone_watcher["confirm_closure"],
                min_strength=config.zone_watcher["min_strength"],
                max_active_zones=config.zone_watcher["max_active_zones"]
            )
            
            self.htf_stack.zone_watcher = ZoneWatcher(zone_config, candidate_config)
            
            # Wire PoolManager to notify ZoneWatcher of pool events
            self.htf_stack.pool_manager.zone_watcher = self.htf_stack.zone_watcher
            
            # Detectors create liquidity pool events (with aggregator injection)
            self.htf_stack.detectors = []
            
            # Only create enabled detectors to save memory
            if config.detectors["fvg"]["enabled"]:
                # Create FVG detectors for each enabled timeframe
                htf_list = getattr(config.strategy, "htf_list", ["H4", "D1"])
                for tf in htf_list:
                    fvg_detector = FVGDetector(
                        tf=tf,
                        min_gap_atr=config.detectors["fvg"].get("min_gap_atr", 0.5),
                        min_gap_pct=config.detectors["fvg"].get("min_gap_pct", 0.001),
                        min_rel_vol=config.detectors["fvg"].get("min_rel_vol", 1.2)
                    )
                    # Store pool manager and aggregator references for runtime use
                    fvg_detector.pool_manager = self.htf_stack.pool_manager
                    fvg_detector.aggregator = self.htf_stack.time_aggregators[tf]
                    self.htf_stack.detectors.append(fvg_detector)
            
            # Only create pivot detector if enabled
            if config.detectors.get("pivot", {}).get("enabled", False):
                logger.warning("Pivot detector requested but not implemented yet")
                # TODO: Add pivot detector when implemented
                # from .pivot_detector import PivotDetector
                # pivot_detector = PivotDetector(config.detectors["pivot"], self.htf_stack.pool_manager)
                # self.htf_stack.detectors.append(pivot_detector)
            
            # For backward compatibility, expose key components as attributes
            self.pool_registry = self.htf_stack.pool_registry
            self.zone_watcher = self.htf_stack.zone_watcher
            self.pool_manager = self.htf_stack.pool_manager
            self.detectors = self.htf_stack.detectors
            self.time_aggregators = self.htf_stack.time_aggregators
            
        else:
            # Fallback to mock for legacy/demo strategies
            logger.info("Using mock zone watcher (legacy mode)")
            # Create a simple FVG detector for 5-minute timeframe
            self.fvg_detector = FVGDetector(
                tf="5m",
                min_gap_atr=0.5,
                min_gap_pct=0.001,
                min_rel_vol=1.2
            )
            self.zone_watcher = MockZoneWatcher(config)
            self.htf_stack = None

        # Metrics
        self.candles_processed = 0

    def shutdown(self):
        """Clean shutdown for all components."""
        if hasattr(self, 'htf_stack') and self.htf_stack:
            self.htf_stack.shutdown()

    def on_candle(self, candle: Candle) -> None:
        """Process incoming candle through the full strategy pipeline.

        Args:
            candle: Market data candle
        """
        with measure_operation("strategy_on_candle"):
            self.candles_processed += 1

            # Update indicators
            with measure_operation("update_indicators"):
                self.indicators.update(candle)

            # Update FVG detector with ATR and volume SMA (for legacy mode)
            with measure_operation("update_detectors"):
                if not hasattr(self, 'htf_stack') or not self.htf_stack:
                    # Only update legacy FVG detector in mock mode
                    atr_value = self.indicators.atr_value
                    vol_sma_value = self.indicators.volume_sma_value

                    # Only update FVG detector if we have indicator values
                    if atr_value is not None and vol_sma_value is not None:
                        self.fvg_detector.update(candle, atr_value, vol_sma_value)

            # Update broker positions first
            with measure_operation("update_positions"):
                self.broker.update_positions(candle)

            # Process strategy based on type
            with measure_operation("check_signals"):
                if hasattr(self, 'htf_stack') and self.htf_stack:
                    # Real HTF strategy workflow
                    signal = self._process_htf_strategy(candle)
                else:
                    # Mock strategy workflow
                    signal = self.zone_watcher.update(candle, self.indicators)

                if signal:
                    # Size position with risk manager
                    size = self.risk_manager.size_position(
                        signal, self.broker.get_balance()
                    )

                    if size > 0:
                        # Submit order to broker
                        self.broker.submit_order(signal, size)

    def _process_htf_strategy(self, candle: Candle) -> Any:
        """Process real HTF liquidity strategy workflow.
        
        Args:
            candle: Current 5-minute source candle
            
        Returns:
            TradingSignal if conditions met, None otherwise
        """
        # 1. Update time aggregators - generates HTF candles
        all_htf_candles = []
        for tf_name, aggregator in self.time_aggregators.items():
            htf_candles = aggregator.update(candle)
            for htf_candle in htf_candles:
                all_htf_candles.append((tf_name, htf_candle))
        
        # 2. Process each HTF candle through detectors
        for tf_name, htf_candle in all_htf_candles:
            atr_value = self.indicators.atr_value
            vol_sma_value = self.indicators.volume_sma_value
            
            if atr_value is not None and vol_sma_value is not None:
                # Run detectors matching this timeframe
                for detector in self.detectors:
                    if hasattr(detector, 'tf') and detector.tf == tf_name:
                        events = detector.update(htf_candle, atr_value, vol_sma_value)
                        
                        # Process events through pool manager
                        if hasattr(detector, 'pool_manager') and detector.pool_manager:
                            for event in events:
                                result = detector.pool_manager.process_detector_event(event)
                                if result.success and result.pool_created:
                                    logger.debug(f"Created pool {result.pool_id} from {tf_name} FVG")
        
        # 3. Check zone watcher for price entries using current 5m candle
        zone_entries = self.zone_watcher.on_price_update(candle)
        
        # 4. Process any zone entries through signal candidate FSM
        for zone_entry in zone_entries:
            candidate = self.zone_watcher.spawn_candidate(zone_entry, candle.ts)
            logger.debug(f"Spawned candidate {candidate.candidate_id} from zone {zone_entry.zone_id}")
        
        # 5. Run candidate FSM for all active candidates
        if hasattr(self.zone_watcher, 'active_candidates'):
            for candidate in list(self.zone_watcher.active_candidates):
                # Update candidate with current bar and indicators
                candidate.update(candle, self.indicators)
                
                # Check if candidate is ready for trading
                if hasattr(candidate, 'is_ready') and candidate.is_ready():
                    # Convert candidate to trading signal
                    signal = candidate.to_signal() if hasattr(candidate, 'to_signal') else None
                    if signal:
                        # Size position with risk manager
                        size = self.risk_manager.size_position(signal, self.broker.get_balance())
                        
                        if size > 0:
                            # Submit order to broker
                            trade_id = self.broker.submit_order(signal, size)
                            logger.info(f"Submitted order {trade_id} from candidate {candidate.candidate_id}")
                            
                            # Mark candidate as submitted
                            if hasattr(candidate, 'mark_submitted'):
                                candidate.mark_submitted(trade_id)
                
                # Clean up expired candidates
                elif hasattr(candidate, 'state') and str(candidate.state).upper() == 'EXPIRED':
                    self.zone_watcher.active_candidates.remove(candidate)
                    logger.debug(f"Removed expired candidate {candidate.candidate_id}")
            
        return None

    def get_performance_stats(self) -> dict[str, Any]:
        """Get strategy performance statistics.

        Returns:
            Dictionary with performance metrics
        """
        trades = self.broker.get_trades()

        if not trades:
            return {
                "total_trades": 0,
                "total_pnl": 0.0,
                "win_rate": 0.0,
                "avg_win": 0.0,
                "avg_loss": 0.0,
                "max_drawdown": 0.0,
                "sharpe_ratio": 0.0,
                "final_balance": self.broker.get_balance(),
            }

        # Calculate basic metrics
        total_trades = len(trades)
        closed_trades = [
            t for t in trades if t["status"] in ["stop_loss", "take_profit"]
        ]
        total_pnl = sum(t["pnl"] for t in closed_trades)

        winning_trades = [t for t in closed_trades if t["pnl"] > 0]
        losing_trades = [t for t in closed_trades if t["pnl"] <= 0]

        win_rate = len(winning_trades) / len(closed_trades) if closed_trades else 0.0
        avg_win = (
            sum(t["pnl"] for t in winning_trades) / len(winning_trades)
            if winning_trades
            else 0.0
        )
        avg_loss = (
            sum(t["pnl"] for t in losing_trades) / len(losing_trades)
            if losing_trades
            else 0.0
        )

        # Simple drawdown calculation
        starting_balance_attr = getattr(self.config, "starting_balance", None)
        starting_balance: float = (
            float(starting_balance_attr)
            if starting_balance_attr is not None
            else 10000.0
        )
        if hasattr(self.config, "account") and hasattr(
            self.config.account, "initial_balance"
        ):
            starting_balance = float(self.config.account.initial_balance)

        balance_history = [starting_balance]
        running_balance = starting_balance

        for trade in closed_trades:
            running_balance += trade["pnl"]
            balance_history.append(running_balance)

        peak = balance_history[0]
        max_drawdown = 0.0

        for balance in balance_history:
            if balance > peak:
                peak = balance
            drawdown = (peak - balance) / peak if peak > 0 else 0.0
            max_drawdown = max(max_drawdown, drawdown)

        # Simple Sharpe ratio (daily returns)
        if len(closed_trades) > 1:
            returns = []
            for i in range(1, len(balance_history)):
                if balance_history[i - 1] > 0:
                    ret = (
                        balance_history[i] - balance_history[i - 1]
                    ) / balance_history[i - 1]
                    returns.append(ret)

            if returns:
                import statistics

                mean_return = statistics.mean(returns)
                std_return = statistics.stdev(returns) if len(returns) > 1 else 0.0
                sharpe_ratio = (
                    mean_return / std_return * (252**0.5) if std_return > 0 else 0.0
                )
            else:
                sharpe_ratio = 0.0
        else:
            sharpe_ratio = 0.0

        return {
            "total_trades": total_trades,
            "closed_trades": len(closed_trades),
            "total_pnl": total_pnl,
            "win_rate": win_rate,
            "avg_win": avg_win,
            "avg_loss": avg_loss,
            "max_drawdown": max_drawdown,
            "sharpe_ratio": sharpe_ratio,
            "final_balance": self.broker.get_balance(),
            "candles_processed": self.candles_processed,
        }


class StrategyFactory:
    """Factory for building complete strategy instances from configuration."""

    @staticmethod
    def build(
        config: Any,
        metrics_collector: MetricsCollector | None = None,
        shared_risk_manager: MockRiskManager | None = None,
    ) -> IntegratedStrategy:
        """Build complete strategy from configuration.

        Args:
            config: Strategy configuration
            metrics_collector: Optional metrics collector
            shared_risk_manager: Optional shared risk manager for ATR warm-up reuse

        Returns:
            Configured IntegratedStrategy instance
        """
        logger.info(f"Building strategy for symbol: {config.strategy.symbol}")

        # Create broker with metrics collector
        broker = MockPaperBroker(config, metrics_collector)

        # Create or reuse risk manager for ATR warm-up caching
        if shared_risk_manager is not None:
            risk_manager = shared_risk_manager
            logger.debug("Reusing shared risk manager for ATR warm-up")
        else:
            risk_manager = MockRiskManager(config)

        # Create integrated strategy
        strategy = IntegratedStrategy(config, broker, risk_manager)

        logger.info("Strategy factory build complete")
        return strategy

    @staticmethod
    def create_test_signal(symbol: str = "BTCUSDT") -> TradingSignal:
        """Create a test trading signal for acceptance testing.

        Args:
            symbol: Trading symbol

        Returns:
            Test TradingSignal
        """
        from datetime import datetime

        return TradingSignal(
            symbol=symbol,
            side="buy",
            entry_price=50000.0,
            stop_loss=49000.0,
            take_profit=52000.0,
            size=100.0,
            timestamp=datetime.now(),
            reason="test_signal",
        )
